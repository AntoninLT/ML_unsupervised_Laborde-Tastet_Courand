# Initial application of DBSCAN with random parameters
labels, silhouette = apply_dbscan_and_evaluate(initial_eps, initial_min_samples)

# Print initial evaluation results
print(f"Initial Parameters: eps={initial_eps}, min_samples={initial_min_samples}")
print(f"Silhouette Score: {silhouette}")

# Measure time of computation
start_time = time.time()

# Iteratively adjust parameters and evaluate
for _ in range(5):  # Adjust the number of iterations as needed
    # Adjust parameters based on previous results (replace with your logic)
    initial_eps += 0.1
    initial_min_samples += 1

    # Apply DBSCAN with adjusted parameters
    dbscan_model = DBSCAN(eps=eps, min_samples=min_samples)
    labels = dbscan_model.fit_predict(X)
    #labels, silhouette = apply_dbscan_and_evaluate(initial_eps, initial_min_samples)

    # Print evaluation results
    print(f"Adjusted Parameters: eps={initial_eps}, min_samples={initial_min_samples}")
    print(f"Silhouette Score: {silhouette}")

# Measure time of computation
end_time = time.time()
elapsed_time = end_time - start_time
print(f"Total time of computation: {elapsed_time} seconds")



initial_eps = 0.5
initial_min_samples = 5

dbscan_model = DBSCAN(eps=initial_eps, min_samples=initial_min_samples)
labels = dbscan_model.fit_predict(X)
silhouette = silhouette_score(X, labels)




initial_eps = 0.5
initial_min_samples = 5

dbscan_model = DBSCAN(eps=initial_eps, min_samples=initial_min_samples).fit(X)
#labels = dbscan_model.fit_predict(X)
labels = dbscan_model.labels_
silhouette = silhouette_score(X, labels)
davies_bouldin_index = metrics.davies_bouldin_score(X, labels)



